#!/bin/busybox sh

set -eo pipefail

/bin/busybox --install

mount -t proc     proc     /proc
mount -t devtmpfs devtmpfs /dev
mount -t sysfs    sysfs    /sys
mount -t tmpfs    tmpfs    /run

eval `cat /proc/cmdline | grep -Eo "rootpart=[0-9]+"`

NEWROOT_DIR=/mnt/newroot

UBOOT_PARTITION=/dev/mmcblk0p1
UBOOT_ENV_PARTITION=/dev/mmcblk0p2
EXTENDED_PARTITION=/dev/mmcblk0p3
FACTORY_PARTITION=/dev/mmcblk0p5

function set_ro() {
	hdparm -r1 "$1" > /dev/null
}

function protect_disk() {
	# whole disk
	set_ro /dev/mmcblk0

	# unique partitions
	set_ro $UBOOT_PARTITION
	set_ro $EXTENDED_PARTITION
	set_ro $FACTORY_PARTITION

	# current slot
	set_ro $KERNEL_PARTITION
	set_ro $ROOT_PARTITION
}

function mount_rootfs_overlay() {
	OVERLAY_DIR=/mnt/overlay
	OVERLAY_LOWER_DIR=$OVERLAY_DIR/lower
	OVERLAY_UPPER_DIR=$OVERLAY_DIR/upper
	OVERLAY_WORK_DIR=$OVERLAY_DIR/work

	# Prepare mount points for overlayfs
	mkdir -p ${OVERLAY_DIR}
	mount -t tmpfs tmpfs ${OVERLAY_DIR}

	# Mount overlayfs
	mkdir -p ${OVERLAY_LOWER_DIR} ${OVERLAY_UPPER_DIR} ${OVERLAY_WORK_DIR} ${NEWROOT_DIR}
	mount -o ro,noload ${ROOT_PARTITION} ${OVERLAY_LOWER_DIR}
	mount -t overlay \
	      -o lowerdir=${OVERLAY_LOWER_DIR},upperdir=${OVERLAY_UPPER_DIR},workdir=${OVERLAY_WORK_DIR} \
	      rootfs-overlay \
	      ${NEWROOT_DIR}
}

function mount_uboot_environment_partition() {
	mkdir -p /boot/uboot
	mount ${UBOOT_ENV_PARTITION} /boot/uboot
	echo "/boot/uboot/uboot.env 0x0000 0x4000" > /etc/fw_env.config
}

function move_uboot_environment_partition() {
	mkdir -p ${NEWROOT_DIR}/boot/uboot
	mount --move /boot/uboot ${NEWROOT_DIR}/boot/uboot
}

function mount_factory_partition() {
	mkdir -p ${NEWROOT_DIR}/factory
	mount -o ro ${FACTORY_PARTITION} ${NEWROOT_DIR}/factory
}

function mount_data_with_retry() {
	mount_cmd=$1

	if ! $mount_cmd ; then
		mount -o bind /dev ${NEWROOT_DIR}/dev

		echo "Error mounting data partition, try fixing with e2fsck"

		# fsck exits with 1 if errors were corrected - just retry mounting regardless of its return code
		chroot ${NEWROOT_DIR} /sbin/e2fsck -f -y "${DATA_PARTITION}" || true

		if $mount_cmd ; then
			echo "Fix successful, data partition mounted"
		else
			echo "Could not fix data partition, wipe it"

			if chroot ${NEWROOT_DIR} /sbin/mkfs.ext4 \
				-F \
				-U clear \
				-E hash_seed=e325e79f-5b5d-4acc-933f-da4c6a9d848c \
				-I 256 \
				"${DATA_PARTITION}" \
				&& $mount_cmd ; then
				echo "Wipe successful, data partition mounted"
			else
				echo "Wipe or mount unsuccessfull, cannot boot"
				exit 1
			fi
		fi

		umount ${NEWROOT_DIR}/dev
	fi
}

function mount_data_partition() {
	eval `fw_printenv bc_update_available`
	eval `fw_printenv bc_bootcount`
	if [ $bc_update_available -gt 0 -a $bc_bootcount -eq 1 ]; then
		if [ $bc_rootpart -eq 6 ]; then
			OLD_DATA_PARTITION=/dev/mmcblk0p11
		else
			OLD_DATA_PARTITION=/dev/mmcblk0p8
		fi
		echo "First boot after update, copy $OLD_DATA_PARTITION to $DATA_PARTITION"
		dd if=$OLD_DATA_PARTITION of=$DATA_PARTITION bs=16M
	fi
	mkdir -p ${NEWROOT_DIR}/data

	# Mount data overlayfs if dataoverlay_enabled file is found
	if [ -f "$NEWROOT_DIR/factory/dataoverlay_enabled" ]; then
		DATAOVERLAY_LOWER_DIR=$OVERLAY_DIR/datalower
		DATAOVERLAY_UPPER_DIR=$OVERLAY_DIR/dataupper
		DATAOVERLAY_WORK_DIR=$OVERLAY_DIR/datawork

		mkdir -p ${DATAOVERLAY_LOWER_DIR} ${DATAOVERLAY_UPPER_DIR} ${DATAOVERLAY_WORK_DIR}

		mount_data_with_retry "mount -o ro ${DATA_PARTITION} ${DATAOVERLAY_LOWER_DIR}"

		mount -t overlay \
			-o lowerdir=${DATAOVERLAY_LOWER_DIR},upperdir=${DATAOVERLAY_UPPER_DIR},workdir=${DATAOVERLAY_WORK_DIR} \
			datafs-overlay \
			${NEWROOT_DIR}/data
	else
		mount_data_with_retry "mount ${DATA_PARTITION} ${NEWROOT_DIR}/data"
	fi
}

function prepare_realroot() {
	local target_script="/tmp/prep_target.sh"
	cat > ${NEWROOT_DIR}/${target_script} <<'EOF'
set -e

function set_mac() {
	local ifname="$1"

	if [ -f "/factory/mac/$ifname" ]; then
		local mac=$(cat "/factory/mac/$ifname")

		echo "setting fixed MAC ($mac) on $ifname"
		ip link set dev "$ifname" address "$mac"

		return 0
	fi

	# only autogenerate MAC addresses for Ethernet-like devices
	local iftype=$(cat "/sys/class/net/${ifname}/type")
	[ "$iftype" -eq 1 ] || return 0

	# only autogenerate addresses when the interface has a volatile address already
	local addr_assign_type=$(cat "/sys/class/net/${ifname}/addr_assign_type")
	[ "$addr_assign_type" -eq 1 -o "$addr_assign_type" -eq 3 ] || return 0

	local mac=$(gcx-hostid genmac "$ifname")
	echo "setting generated MAC ($mac) on $ifname"
	ip link set dev "$ifname" address "$mac"

	return 0
}

mount -t sysfs none /sys

# set hostname
HOSTID=$(gcx-hostid)
echo "@@BR2_TARGET_GENERIC_HOSTNAME@@-${HOSTID}"> /etc/hostname

# set machine-id
gcx-hostid derive machine-id | head -c 32  > /etc/machine-id

# set persistent MAC addresses
for iface in /sys/class/net/*
do
	set_mac ${iface##*/}
done

umount /sys

EOF

	chroot ${NEWROOT_DIR} /bin/sh ${target_script}
	rm ${NEWROOT_DIR}/${target_script}

	if [ -x ${NEWROOT_DIR}/data/rc.local.preinit ]; then
		chroot ${NEWROOT_DIR} /data/rc.local.preinit || true
	fi
}

function create_partitions()
{
    local image_file="$1"

    sed -e 's/\s*\([\+0-9a-zA-Z]*\).*/\1/' <<EOF | fdisk "$image_file"
    #p # print partition table

    d # remove last partition to make empty spaces in the end
    8 # with number 8

    n # new partition
    l # logical partition
    1071104 # start at beginning of the disk
    +400M # size 400 MB
    t  # set partition type
    8  # with number 8
    83 # to 'linux'

    n # new partition
    l # logical partition
    1892352 # start at beginning of the disk
    +32M # size 32 MB
    t  # set partition type
    9  # with number 9
    0C # to 'vfat'

    n # new partition
    l # logical partition
    1959936 # start at beginning of the disk
    +480M # size 480 MB
    t  # set partition type
    10 # with number 10
    83 # to 'linux'

    n # new partition
    l # logical partition
    2945024 # start at beginning of the disk
      # default - to the end of the disk
    #+400M # size 400M
    t  # set partition type
    11 # with number 11
    83 # to 'linux'

    #p # print partition table
    w # write settings
    q # quit
EOF
}

if [ ! -e /dev/mmcblk0p9 ]; then
    echo "Secondary partitions do not exist"
    create_partitions /dev/mmcblk0
    dd if=/dev/mmcblk0p6 of=/dev/mmcblk0p9 bs=16M
    dd if=/dev/mmcblk0p7 of=/dev/mmcblk0p10 bs=16M
fi

mount_uboot_environment_partition

eval `fw_printenv bc_rootpart`

KERNEL_PARTITION=/dev/mmcblk0p$((bc_rootpart+0))
ROOT_PARTITION=/dev/mmcblk0p$((bc_rootpart+1))
DATA_PARTITION=/dev/mmcblk0p$((bc_rootpart+2))

protect_disk
mount_rootfs_overlay
mount_factory_partition
mount_data_partition

move_uboot_environment_partition

prepare_realroot

# Switch to new rootfs
exec switch_root ${NEWROOT_DIR} /sbin/init
