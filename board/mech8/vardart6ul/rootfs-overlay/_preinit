#!/bin/sh

set -x

SPI_DEV=/dev/mtdblock4
BLK_DEV=/dev/mmcblk0
MMC_DEV=${BLK_DEV}p
PART_ROOTFSB=${MMC_DEV}3
PART_EXTENDED=${MMC_DEV}4
PART_BACKUP=${MMC_DEV}5
PART_USER=${MMC_DEV}6
PRM_RSTST=0x44E00F08

panic()
{
    echo b > /proc/sysrq-trigger
}

check_ext4_partition()
{
    local PARTITION="$1"
    local MOUNT_POINT="$2"

    mount -o ro $PARTITION $MOUNT_POINT
    if [ $? -eq 0 ]; then
        umount $PARTITION
    else
        yes | mkfs.ext4 $PARTITION
    fi
    yes | e2fsck -f $PARTITION
}

write_bootinfo()
{
  local PARTITION="$1"
  local MOUNT_POINT="$2"

  mount -o rw $PARTITION $MOUNT_POINT || panic
  BOOTCOUNTER=$(cat ${MOUNT_POINT}/bootcounter) || BOOTCOUNTER=0
  BOOTCOUNTER=$(( $BOOTCOUNTER + 1 ))
  echo $BOOTCOUNTER >${MOUNT_POINT}/bootcounter

  devmem $PRM_RSTST >${MOUNT_POINT}/resetcause
  devmem $PRM_RSTST w 0x233 # As stated in the TRM: the register must be cleared by software.

  umount $SPI_DEV
}

create_partitions()
{
  # Wipe extended parition out if there is one.
  dd if=/dev/zero of=${BLK_DEV} bs=512 count=2048 seek=1097728

sed -e 's/\s*\([\+0-9a-zA-Z]*\).*/\1/' <<EOF | fdisk $BLK_DEV
  n # new partition
  p # primary partition
  3 # partition number 3
  573440 # start sector
  +256M # 256 MB boot partition
  n # new partition
  e # extended partition
  1097728 # start sector
    # default, extend partition to end of disk
  t # change
  4 # partition type
  f # to Windows LBA
  p # print new partition table
  w # write new partition table
  q # and we're done
EOF

sed -e 's/\s*\([\+0-9a-zA-Z]*\).*/\1/' <<EOF | fdisk $BLK_DEV
  n # new partition
  1114112 # start sector
  +512M # 512 MB boot parttion
  n # new partition
  2179072 # start sector
  +512M # 512 MB boot parttion
  p # print new partition table
  w # write new partition table
  q # and we're done
EOF

 # Reread paritions on next boot.
  echo b > /proc/sysrq-trigger
}

mount -t proc none /proc
mount -t tmpfs tmpfs /tmp
mount -t sysfs sys /sys

# Comment out if you want the console.
#sh

# Check of ~PF_INT is still signalling power fail. Take care of the
# active-low pin logic: 0 - power fail, 1 - no power fail.
PWRFAIL=$(gpioget -l gpiochip0 29)
test $PWRFAIL -eq 0 || panic

if [ ! -b $PART_ROOTFSB ]; then
  create_partitions
fi

check_ext4_partition $PART_BACKUP /mnt/tmp
check_ext4_partition $PART_USER /mnt/tmp
check_ext4_partition $SPI_DEV /mnt/tmp
write_bootinfo $SPI_DEV /mnt/tmp

mount -o rw,noatime $PART_USER /overlayfs/rootfs_rw || panic
mkdir -p /overlayfs/rootfs_rw/rootfs || panic
mkdir -p /overlayfs/rootfs_rw/workdir || panic

mount --bind / /overlayfs/rootfs_ro
mount -t overlay -o lowerdir=/overlayfs/rootfs_ro,upperdir=/overlayfs/rootfs_rw/rootfs,workdir=/overlayfs/rootfs_rw/workdir overlay /rootfs

mount --move /overlayfs/rootfs_ro /rootfs/overlayfs/rootfs_ro
mount --move /overlayfs/rootfs_rw /rootfs/overlayfs/rootfs_rw
mount --move /dev /rootfs/dev

umount /proc
umount /tmp
umount /sys

exec /sbin/chroot /rootfs /sbin/init
